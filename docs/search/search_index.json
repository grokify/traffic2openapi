{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Traffic2OpenAPI","text":"<p>Generate OpenAPI 3.0/3.1/3.2 specifications from HTTP traffic logs.</p> <p>Traffic2OpenAPI captures HTTP request/response traffic from multiple sources, normalizes it to a shared Intermediate Representation (IR), and generates OpenAPI specs through intelligent inference.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Multi-source input: IR files from HAR files, browser automation, proxy captures, or manual capture</li> <li>Intelligent inference: Automatically detects path parameters, query params, schemas</li> <li>OpenAPI 3.0/3.1/3.2: Generate specs for any version</li> <li>Format detection: Email, UUID, date-time, URI, IPv4/IPv6</li> <li>Type inference: String, integer, number, boolean, array, object</li> <li>Required/optional: Tracks field presence across requests</li> <li>Provider pattern: Symmetric read/write access for IR records</li> <li>Storage integration: Works with omnistorage for cloud storage backends</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code># Install\ngo install github.com/grokify/traffic2openapi/cmd/traffic2openapi@latest\n\n# Convert HAR file to IR format\ntraffic2openapi convert har -i recording.har -o traffic.ndjson\n\n# Generate OpenAPI spec from IR\ntraffic2openapi generate -i traffic.ndjson -o openapi.yaml\n</code></pre>"},{"location":"#go-package-usage","title":"Go Package Usage","text":"<pre><code>import (\n    \"github.com/grokify/traffic2openapi/pkg/ir\"\n    \"github.com/grokify/traffic2openapi/pkg/inference\"\n    \"github.com/grokify/traffic2openapi/pkg/openapi\"\n)\n\n// Read IR records\nrecords, err := ir.ReadFile(\"traffic.ndjson\")\n\n// Infer API structure\nengine := inference.NewEngine(inference.DefaultEngineOptions())\nengine.ProcessRecords(records)\nresult := engine.Finalize()\n\n// Generate OpenAPI spec\nspec := openapi.GenerateFromInference(result, openapi.DefaultGeneratorOptions())\nopenapi.WriteFile(\"openapi.yaml\", spec)\n</code></pre>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>Traffic Sources \u2192 Adapters \u2192 IR (Intermediate Representation) \u2192 Inference Engine \u2192 OpenAPI Spec\n</code></pre> <p>See the Architecture page for details.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Installation and quick start guide</li> <li>Concepts - Architecture and IR format</li> <li>Go Packages - Provider pattern, LoggingTransport, inference</li> <li>Adapters - HAR, browser automation, proxy captures</li> <li>CLI Reference - Command-line interface</li> </ul>"},{"location":"adapters/browser/","title":"Browser &amp; Test Automation","text":"<p>Capture HTTP traffic from browsers and test automation frameworks.</p>"},{"location":"adapters/browser/#overview","title":"Overview","text":"Method Tool Streaming Best For Playwright Adapter Playwright (Python/TS) Yes Recommended HAR Export DevTools, Playwright No Post-hoc analysis Event-based Playwright, Puppeteer Yes Real-time capture Intercept Cypress Yes E2E test suites"},{"location":"adapters/browser/#playwright-adapter-recommended","title":"Playwright Adapter (Recommended)","text":"<p>We provide official Playwright adapters for Python and TypeScript. These handle all the complexity of capturing traffic and outputting IR format.</p> <p>Location: <code>pkg/adapters/playwright/</code></p>"},{"location":"adapters/browser/#why-playwright-adapter","title":"Why Playwright Adapter?","text":"<ul> <li>Streaming - Records are written as they happen, not buffered in memory</li> <li>Filtering - Built-in host, method, and path filtering</li> <li>Security - Automatically excludes sensitive headers</li> <li>Compression - Optional gzip output for large captures</li> <li>Type-safe - Full TypeScript types and Python type hints</li> <li>Test integration - Works with pytest and @playwright/test</li> </ul>"},{"location":"adapters/browser/#installation","title":"Installation","text":"PythonTypeScript <pre><code>pip install traffic2openapi-playwright\n</code></pre> <pre><code>npm install traffic2openapi-playwright\n</code></pre>"},{"location":"adapters/browser/#quick-start","title":"Quick Start","text":"Python (Sync)Python (Async)TypeScript <pre><code>from playwright.sync_api import sync_playwright\nfrom traffic2openapi_playwright import PlaywrightCapture\n\nwith sync_playwright() as p:\n    browser = p.chromium.launch()\n    context = browser.new_context()\n\n    # Start capturing\n    capture = PlaywrightCapture(\"traffic.ndjson\")\n    capture.attach(context)\n\n    page = context.new_page()\n    page.goto(\"https://api.example.com/users\")\n\n    # Stop and save\n    capture.close()\n    browser.close()\n\nprint(f\"Captured {capture.count} requests\")\n</code></pre> <pre><code>import asyncio\nfrom playwright.async_api import async_playwright\nfrom traffic2openapi_playwright import PlaywrightCapture\n\nasync def main():\n    async with async_playwright() as p:\n        browser = await p.chromium.launch()\n        context = await browser.new_context()\n\n        capture = PlaywrightCapture(\"traffic.ndjson\")\n        await capture.attach_async(context)\n\n        page = await context.new_page()\n        await page.goto(\"https://api.example.com/users\")\n\n        capture.close()\n        await browser.close()\n\nasyncio.run(main())\n</code></pre> <pre><code>import { chromium } from 'playwright';\nimport { PlaywrightCapture } from 'traffic2openapi-playwright';\n\nconst browser = await chromium.launch();\nconst context = await browser.newContext();\n\n// Start capturing\nconst capture = new PlaywrightCapture('traffic.ndjson');\ncapture.attach(context);\n\nconst page = await context.newPage();\nawait page.goto('https://api.example.com/users');\n\n// Stop and save\nawait capture.close();\nawait browser.close();\n\nconsole.log(`Captured ${capture.count} requests`);\n</code></pre>"},{"location":"adapters/browser/#configuration","title":"Configuration","text":"<p>Both adapters support the same configuration options:</p> Option Default Description <code>output</code> (required) Output file path <code>filter_hosts</code> / <code>filterHosts</code> <code>[]</code> Only capture requests to these hosts <code>filter_methods</code> / <code>filterMethods</code> <code>[]</code> Only capture these HTTP methods <code>exclude_paths</code> / <code>excludePaths</code> <code>[]</code> Skip requests matching these paths <code>exclude_path_patterns</code> / <code>excludePathPatterns</code> <code>[]</code> Skip paths matching regex patterns <code>exclude_headers</code> / <code>excludeHeaders</code> See below Headers to exclude <code>capture_request_body</code> / <code>captureRequestBody</code> <code>true</code> Capture request bodies <code>capture_response_body</code> / <code>captureResponseBody</code> <code>true</code> Capture response bodies <code>max_body_size</code> / <code>maxBodySize</code> <code>1048576</code> Max body size in bytes (1MB) <code>gzip</code> <code>false</code> Gzip compress output (auto-detected from <code>.gz</code>) <code>compression_level</code> / <code>compressionLevel</code> <code>9</code> Gzip level 1-9 <code>on_error</code> / <code>onError</code> <code>None</code> Error callback function <p>Default excluded headers:</p> <ul> <li><code>authorization</code></li> <li><code>cookie</code></li> <li><code>set-cookie</code></li> <li><code>x-api-key</code></li> <li><code>x-auth-token</code></li> </ul>"},{"location":"adapters/browser/#filtering-traffic","title":"Filtering Traffic","text":"<p>Filter to only capture your API traffic:</p> PythonTypeScript <pre><code>import re\nfrom traffic2openapi_playwright import PlaywrightCapture, CaptureOptions\n\noptions = CaptureOptions(\n    output=\"traffic.ndjson\",\n\n    # Only capture your API\n    filter_hosts=[\"api.example.com\"],\n\n    # Only capture these methods\n    filter_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n\n    # Exclude health checks and internal routes\n    exclude_paths=[\"/health\", \"/metrics\", \"/version\"],\n\n    # Exclude static assets\n    exclude_path_patterns=[\n        re.compile(r\"\\.(js|css|png|jpg|svg|woff2?)$\"),\n        re.compile(r\"^/_next/\"),\n    ],\n)\n\ncapture = PlaywrightCapture(options)\n</code></pre> <pre><code>import { PlaywrightCapture } from 'traffic2openapi-playwright';\n\nconst capture = new PlaywrightCapture({\n  output: 'traffic.ndjson',\n\n  // Only capture your API\n  filterHosts: ['api.example.com'],\n\n  // Only capture these methods\n  filterMethods: ['GET', 'POST', 'PUT', 'DELETE'],\n\n  // Exclude health checks and internal routes\n  excludePaths: ['/health', '/metrics', '/version'],\n\n  // Exclude static assets\n  excludePathPatterns: [\n    /\\.(js|css|png|jpg|svg|woff2?)$/,\n    /^\\/_next\\//,\n  ],\n});\n</code></pre>"},{"location":"adapters/browser/#test-framework-integration","title":"Test Framework Integration","text":""},{"location":"adapters/browser/#pytest-python","title":"pytest (Python)","text":"<pre><code># conftest.py\nimport pytest\nfrom playwright.sync_api import sync_playwright\nfrom traffic2openapi_playwright import PlaywrightCapture\n\n@pytest.fixture(scope=\"session\")\ndef playwright_instance():\n    with sync_playwright() as p:\n        yield p\n\n@pytest.fixture(scope=\"session\")\ndef browser(playwright_instance):\n    browser = playwright_instance.chromium.launch()\n    yield browser\n    browser.close()\n\n@pytest.fixture(scope=\"session\")\ndef traffic_capture():\n    capture = PlaywrightCapture(\"test-traffic.ndjson\")\n    yield capture\n    capture.close()\n\n@pytest.fixture\ndef context(browser, traffic_capture):\n    context = browser.new_context()\n    traffic_capture.attach(context)\n    yield context\n    context.close()\n\n@pytest.fixture\ndef page(context):\n    page = context.new_page()\n    yield page\n    page.close()\n</code></pre> <pre><code># test_api.py\ndef test_get_users(page):\n    response = page.goto(\"https://api.example.com/users\")\n    assert response.status == 200\n\ndef test_create_user(page):\n    page.goto(\"https://api.example.com\")\n    # ... perform actions\n</code></pre>"},{"location":"adapters/browser/#playwrighttest-typescript","title":"@playwright/test (TypeScript)","text":"<pre><code>// tests/fixtures.ts\nimport { test as base } from '@playwright/test';\nimport { PlaywrightCapture } from 'traffic2openapi-playwright';\n\nexport const test = base.extend&lt;{}, { capture: PlaywrightCapture }&gt;({\n  capture: [async ({}, use) =&gt; {\n    const capture = new PlaywrightCapture({\n      output: 'test-traffic.ndjson',\n      filterHosts: ['api.example.com'],\n    });\n    await use(capture);\n    await capture.close();\n  }, { scope: 'worker' }],\n});\n\nexport { expect } from '@playwright/test';\n</code></pre> <pre><code>// tests/api.spec.ts\nimport { test, expect } from './fixtures';\n\ntest.beforeEach(async ({ context, capture }) =&gt; {\n  capture.attach(context);\n});\n\ntest('should get users', async ({ page }) =&gt; {\n  const response = await page.goto('/users');\n  expect(response?.status()).toBe(200);\n});\n</code></pre>"},{"location":"adapters/browser/#generating-openapi","title":"Generating OpenAPI","text":"<p>After capturing traffic:</p> <pre><code># Generate OpenAPI spec\ntraffic2openapi generate -i traffic.ndjson -o openapi.yaml\n\n# With gzip input\ntraffic2openapi generate -i traffic.ndjson.gz -o openapi.yaml\n</code></pre>"},{"location":"adapters/browser/#full-documentation","title":"Full Documentation","text":"<p>For complete API reference and examples:</p> <ul> <li>Python README</li> <li>TypeScript README</li> </ul>"},{"location":"adapters/browser/#alternative-har-recording","title":"Alternative: HAR Recording","text":"<p>If you prefer using Playwright's built-in HAR recording:</p> <pre><code>const context = await browser.newContext({\n  recordHar: { path: 'traffic.har', content: 'embed' }\n});\n\nconst page = await context.newPage();\nawait page.goto('https://api.example.com');\n// ... perform actions ...\n\nawait context.close();  // HAR written here\n\n// Convert to IR\n// $ traffic2openapi convert har -i traffic.har -o traffic.ndjson\n</code></pre> <p>Pros:</p> <ul> <li>Built into Playwright</li> <li>No additional dependencies</li> </ul> <p>Cons:</p> <ul> <li>Not streaming (all in memory until close)</li> <li>Requires conversion step</li> <li>Less filtering control</li> </ul>"},{"location":"adapters/browser/#alternative-manual-event-capture","title":"Alternative: Manual Event Capture","text":"<p>For custom capture logic or frameworks without adapters:</p> <pre><code>import { chromium } from 'playwright';\nimport * as fs from 'fs';\n\nconst browser = await chromium.launch();\nconst context = await browser.newContext();\nconst page = await context.newPage();\n\nconst records: any[] = [];\n\n// Capture responses (includes request info)\npage.on('response', async response =&gt; {\n  const request = response.request();\n  const url = new URL(request.url());\n\n  // Filter to API calls only\n  if (!url.hostname.includes('api.example.com')) return;\n\n  const record = {\n    id: crypto.randomUUID(),\n    timestamp: new Date().toISOString(),\n    source: 'playwright',\n    request: {\n      method: request.method(),\n      path: url.pathname,\n      host: url.hostname,\n      query: Object.fromEntries(url.searchParams),\n      headers: request.headers(),\n    },\n    response: {\n      status: response.status(),\n      headers: response.headers(),\n      body: await response.json().catch(() =&gt; null),\n    },\n  };\n  records.push(record);\n});\n\nawait page.goto('https://api.example.com');\n// ... perform actions ...\n\n// Write NDJSON\nfs.writeFileSync('traffic.ndjson',\n  records.map(r =&gt; JSON.stringify(r)).join('\\n') + '\\n');\n\nawait browser.close();\n</code></pre>"},{"location":"adapters/browser/#cypress","title":"Cypress","text":""},{"location":"adapters/browser/#network-intercept","title":"Network Intercept","text":"<pre><code>// cypress/e2e/capture.cy.ts\ndescribe('API Capture', () =&gt; {\n  const records: any[] = [];\n\n  beforeEach(() =&gt; {\n    cy.intercept('**/api/**', (req) =&gt; {\n      req.continue((res) =&gt; {\n        records.push({\n          id: crypto.randomUUID(),\n          timestamp: new Date().toISOString(),\n          source: 'cypress',\n          request: {\n            method: req.method,\n            path: new URL(req.url).pathname,\n            headers: req.headers,\n            body: req.body,\n          },\n          response: {\n            status: res.statusCode,\n            headers: res.headers,\n            body: res.body,\n          },\n        });\n      });\n    });\n  });\n\n  after(() =&gt; {\n    cy.writeFile('traffic.ndjson',\n      records.map(r =&gt; JSON.stringify(r)).join('\\n') + '\\n');\n  });\n\n  it('captures API traffic', () =&gt; {\n    cy.visit('/');\n    // ... test actions ...\n  });\n});\n</code></pre>"},{"location":"adapters/browser/#puppeteer","title":"Puppeteer","text":""},{"location":"adapters/browser/#cdp-based-capture","title":"CDP-based Capture","text":"<pre><code>import puppeteer from 'puppeteer';\nimport * as fs from 'fs';\n\nconst browser = await puppeteer.launch();\nconst page = await browser.newPage();\n\nconst records: any[] = [];\n\nawait page.setRequestInterception(true);\n\npage.on('request', request =&gt; {\n  request.continue();\n});\n\npage.on('response', async response =&gt; {\n  const request = response.request();\n  const url = new URL(request.url());\n\n  records.push({\n    id: crypto.randomUUID(),\n    timestamp: new Date().toISOString(),\n    source: 'puppeteer',\n    request: {\n      method: request.method(),\n      path: url.pathname,\n      host: url.hostname,\n      headers: request.headers(),\n    },\n    response: {\n      status: response.status(),\n      headers: response.headers(),\n      body: await response.text().catch(() =&gt; null),\n    },\n  });\n});\n\nawait page.goto('https://api.example.com');\n// ... perform actions ...\n\nfs.writeFileSync('traffic.ndjson',\n  records.map(r =&gt; JSON.stringify(r)).join('\\n') + '\\n');\n\nawait browser.close();\n</code></pre>"},{"location":"adapters/browser/#chrome-devtools","title":"Chrome DevTools","text":""},{"location":"adapters/browser/#manual-export","title":"Manual Export","text":"<ol> <li>Open DevTools (F12)</li> <li>Go to Network tab</li> <li>Check \"Preserve log\" to capture across navigations</li> <li>Perform API operations</li> <li>Right-click \u2192 \"Save all as HAR with content\"</li> <li>Convert: <code>traffic2openapi convert har -i traffic.har -o traffic.ndjson</code></li> </ol>"},{"location":"adapters/browser/#devtools-protocol","title":"DevTools Protocol","text":"<pre><code>// Use Chrome DevTools Protocol for programmatic capture\nconst CDP = require('chrome-remote-interface');\n\nconst client = await CDP();\nconst { Network } = client;\n\nawait Network.enable();\n\nNetwork.requestWillBeSent((params) =&gt; {\n  console.log('Request:', params.request.url);\n});\n\nNetwork.responseReceived((params) =&gt; {\n  console.log('Response:', params.response.status);\n});\n</code></pre>"},{"location":"adapters/browser/#best-practices","title":"Best Practices","text":""},{"location":"adapters/browser/#1-filter-api-traffic","title":"1. Filter API Traffic","text":"<p>Exclude static assets, third-party requests, and internal routes:</p> <pre><code>exclude_path_patterns=[\n    re.compile(r\"\\.(js|css|png|jpg|gif|svg|ico|woff2?)$\"),\n    re.compile(r\"^/_next/\"),\n    re.compile(r\"^/sockjs-node/\"),\n    re.compile(r\"^/__webpack_hmr\"),\n]\n</code></pre>"},{"location":"adapters/browser/#2-capture-during-tests","title":"2. Capture During Tests","text":"<p>Use E2E tests to generate comprehensive traffic that covers:</p> <ul> <li>All API endpoints</li> <li>Different HTTP methods</li> <li>Various request payloads</li> <li>Success and error responses</li> </ul>"},{"location":"adapters/browser/#3-include-error-cases","title":"3. Include Error Cases","text":"<p>Capture 4xx/5xx responses for complete schemas:</p> <pre><code># Don't filter by status - capture all responses\n# The adapter captures everything by default\n</code></pre>"},{"location":"adapters/browser/#4-use-realistic-data","title":"4. Use Realistic Data","text":"<p>Representative request bodies improve schema inference:</p> <pre><code>// Good - realistic data\nawait page.evaluate(async () =&gt; {\n  await fetch('/users', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      name: 'Alice Smith',\n      email: 'alice@example.com',\n      age: 30,\n      roles: ['admin', 'user'],\n    }),\n  });\n});\n</code></pre>"},{"location":"adapters/browser/#5-compress-large-captures","title":"5. Compress Large Captures","text":"<p>For extensive test suites:</p> <pre><code>capture = PlaywrightCapture(\"traffic.ndjson.gz\")  # Auto-gzip\n</code></pre>"},{"location":"adapters/browser/#6-exclude-sensitive-headers","title":"6. Exclude Sensitive Headers","text":"<p>The adapters exclude auth headers by default, but verify for your use case:</p> <pre><code>exclude_headers={\n    \"authorization\",\n    \"cookie\",\n    \"x-api-key\",\n    \"x-internal-token\",\n}\n</code></pre>"},{"location":"adapters/har/","title":"HAR Adapter","text":"<p>Convert HAR (HTTP Archive) files to IR format.</p>"},{"location":"adapters/har/#overview","title":"Overview","text":"<p>HAR is a standard format supported by:</p> <ul> <li>Browser DevTools: Chrome, Firefox, Safari (Network tab \u2192 Save as HAR)</li> <li>Playwright: Built-in <code>recordHar</code> option</li> <li>Charles Proxy: File \u2192 Export Session as HAR</li> <li>Fiddler: File \u2192 Export \u2192 HTTPArchive</li> <li>mitmproxy: <code>mitmdump --save-stream-file</code></li> <li>Postman: Collection export</li> </ul>"},{"location":"adapters/har/#cli-usage","title":"CLI Usage","text":"<pre><code># Convert a single HAR file\ntraffic2openapi convert har -i recording.har -o traffic.ndjson\n\n# Convert multiple HAR files from a directory\ntraffic2openapi convert har -i ./har-files/ -o traffic.ndjson\n\n# Filter by host\ntraffic2openapi convert har -i recording.har -o traffic.ndjson --host api.example.com\n\n# Filter by method\ntraffic2openapi convert har -i recording.har -o traffic.ndjson --method POST\n\n# Exclude headers from output\ntraffic2openapi convert har -i recording.har -o traffic.ndjson --headers=false\n</code></pre>"},{"location":"adapters/har/#capturing-har-files","title":"Capturing HAR Files","text":""},{"location":"adapters/har/#browser-devtools","title":"Browser DevTools","text":"<ol> <li>Open DevTools (F12)</li> <li>Go to Network tab</li> <li>Perform your API operations</li> <li>Right-click in the network panel \u2192 \"Save all as HAR with content\"</li> </ol>"},{"location":"adapters/har/#playwright","title":"Playwright","text":"<pre><code>const context = await browser.newContext({\n  recordHar: { path: 'traffic.har', content: 'embed' }\n});\n\nawait page.goto('https://api.example.com');\n// ... perform actions ...\n\nawait context.close();  // HAR file written here\n</code></pre>"},{"location":"adapters/har/#charles-proxy","title":"Charles Proxy","text":"<ol> <li>File \u2192 Start Recording</li> <li>Perform API operations</li> <li>File \u2192 Export Session \u2192 HTTPArchive (.har)</li> </ol>"},{"location":"adapters/har/#go-package-usage","title":"Go Package Usage","text":"<pre><code>import \"github.com/grokify/traffic2openapi/pkg/adapters/har\"\n\n// Read HAR file\nreader := har.NewReader()\nrecords, err := reader.ReadFile(\"recording.har\")\n\n// Read directory of HAR files\nrecords, err := reader.ReadDir(\"./har-files/\")\n\n// Parse HAR and filter\nh, err := har.ParseFile(\"recording.har\")\napiEntries := har.FilterByHost(h, \"api.example.com\")\npostEntries := har.FilterByMethod(h, \"POST\")\n</code></pre>"},{"location":"adapters/har/#configuration","title":"Configuration","text":""},{"location":"adapters/har/#header-filtering","title":"Header Filtering","text":"<p>By default, sensitive headers are excluded:</p> <ul> <li><code>authorization</code></li> <li><code>cookie</code> / <code>set-cookie</code></li> <li><code>x-api-key</code></li> <li><code>x-auth-token</code></li> <li><code>x-csrf-token</code></li> <li><code>proxy-authorization</code></li> </ul> <p>Customize:</p> <pre><code>reader := har.NewReader()\nreader.Converter.IncludeHeaders = true\nreader.Converter.FilterHeaders = []string{\"authorization\", \"x-api-key\"}\n</code></pre>"},{"location":"adapters/har/#cookie-handling","title":"Cookie Handling","text":"<pre><code>reader.Converter.IncludeCookies = false  // Exclude cookies (default)\n</code></pre>"},{"location":"adapters/har/#full-workflow","title":"Full Workflow","text":"<pre><code># 1. Export HAR from browser\n# 2. Convert to IR\ntraffic2openapi convert har -i browser-recording.har -o traffic.ndjson\n\n# 3. Generate OpenAPI\ntraffic2openapi generate -i traffic.ndjson -o openapi.yaml \\\n    --title \"My API\" \\\n    --server https://api.example.com\n</code></pre>"},{"location":"adapters/overview/","title":"Adapters Overview","text":"<p>Adapters convert traffic from various sources to the IR format.</p>"},{"location":"adapters/overview/#available-adapters","title":"Available Adapters","text":"Adapter Source Request Body Response Body Setup HAR Browser DevTools, proxies Yes Yes Low Browser Playwright, Cypress Yes Yes Low LoggingTransport Go http.Client Yes Yes Low Proxy Captures mitmproxy, Charles Yes Yes Low-Medium"},{"location":"adapters/overview/#choosing-an-adapter","title":"Choosing an Adapter","text":""},{"location":"adapters/overview/#for-developmenttesting","title":"For Development/Testing","text":"<ul> <li>HAR files: Export from browser DevTools</li> <li>LoggingTransport: Capture from Go http.Client</li> <li>Playwright/Cypress: Capture during E2E tests</li> </ul>"},{"location":"adapters/overview/#for-production-traffic","title":"For Production Traffic","text":"<ul> <li>Proxy captures: mitmproxy, Charles Proxy</li> <li>LoggingTransport: Wrap production http.Client</li> </ul>"},{"location":"adapters/overview/#for-quick-discovery","title":"For Quick Discovery","text":"<ul> <li>HAR files: Quick export from browser DevTools</li> <li>Playwright: Automated test traffic capture</li> </ul>"},{"location":"adapters/overview/#fidelity-comparison","title":"Fidelity Comparison","text":"Feature HAR Playwright LoggingTransport Proxy Request Headers Yes Yes Yes Yes Request Body Yes Yes Yes Yes Response Headers Yes Yes Yes Yes Response Body Yes Yes Yes Yes Query Params Yes Yes Yes Yes Timing Yes Yes Yes Yes Request ID Varies Yes Yes Varies"},{"location":"adapters/overview/#common-workflow","title":"Common Workflow","text":"<ol> <li>Capture: Use an adapter to capture HTTP traffic</li> <li>Convert: Convert to IR format (NDJSON)</li> <li>Analyze: Run inference engine</li> <li>Generate: Create OpenAPI spec</li> </ol> <pre><code># Example with HAR\ntraffic2openapi convert har -i recording.har -o traffic.ndjson\ntraffic2openapi generate -i traffic.ndjson -o openapi.yaml\n</code></pre>"},{"location":"adapters/overview/#custom-adapters","title":"Custom Adapters","text":"<p>You can create custom adapters by implementing the IR record format:</p> <pre><code>// Convert your traffic format to IR records\nfunc ConvertToIR(yourData YourFormat) *ir.IRRecord {\n    return ir.NewRecord(\n        ir.RequestMethod(yourData.Method),\n        yourData.Path,\n        yourData.StatusCode,\n    ).\n        SetHost(yourData.Host).\n        SetRequestBody(yourData.RequestBody).\n        SetResponseBody(yourData.ResponseBody)\n}\n\n// Write to IR file\nprovider := ir.NDJSON()\nwriter, _ := provider.NewWriter(ctx, \"output.ndjson\")\nfor _, data := range yourTraffic {\n    writer.Write(ConvertToIR(data))\n}\nwriter.Close()\n</code></pre>"},{"location":"api/ir/","title":"pkg/ir API Reference","text":"<p>The <code>ir</code> package provides types and utilities for working with Intermediate Representation data.</p>"},{"location":"api/ir/#types","title":"Types","text":""},{"location":"api/ir/#irrecord","title":"IRRecord","text":"<p>Represents a single HTTP request/response capture.</p> <pre><code>type IRRecord struct {\n    ID         *string           `json:\"id,omitempty\"`\n    Timestamp  *string           `json:\"timestamp,omitempty\"`\n    Source     *IRRecordSource   `json:\"source,omitempty\"`\n    Request    Request           `json:\"request\"`\n    Response   Response          `json:\"response\"`\n    DurationMs *float64          `json:\"durationMs,omitempty\"`\n}\n</code></pre>"},{"location":"api/ir/#request","title":"Request","text":"<p>HTTP request details.</p> <pre><code>type Request struct {\n    Method       RequestMethod     `json:\"method\"`\n    Scheme       *string           `json:\"scheme,omitempty\"`\n    Host         *string           `json:\"host,omitempty\"`\n    Path         string            `json:\"path\"`\n    PathTemplate *string           `json:\"pathTemplate,omitempty\"`\n    PathParams   map[string]string `json:\"pathParams,omitempty\"`\n    Query        map[string]string `json:\"query,omitempty\"`\n    Headers      map[string]string `json:\"headers,omitempty\"`\n    ContentType  *string           `json:\"contentType,omitempty\"`\n    Body         interface{}       `json:\"body,omitempty\"`\n}\n</code></pre>"},{"location":"api/ir/#response","title":"Response","text":"<p>HTTP response details.</p> <pre><code>type Response struct {\n    Status      int               `json:\"status\"`\n    Headers     map[string]string `json:\"headers,omitempty\"`\n    ContentType *string           `json:\"contentType,omitempty\"`\n    Body        interface{}       `json:\"body,omitempty\"`\n}\n</code></pre>"},{"location":"api/ir/#requestmethod","title":"RequestMethod","text":"<p>HTTP method enum.</p> <pre><code>type RequestMethod string\n\nconst (\n    RequestMethodGET     RequestMethod = \"GET\"\n    RequestMethodPOST    RequestMethod = \"POST\"\n    RequestMethodPUT     RequestMethod = \"PUT\"\n    RequestMethodPATCH   RequestMethod = \"PATCH\"\n    RequestMethodDELETE  RequestMethod = \"DELETE\"\n    RequestMethodHEAD    RequestMethod = \"HEAD\"\n    RequestMethodOPTIONS RequestMethod = \"OPTIONS\"\n)\n</code></pre>"},{"location":"api/ir/#interfaces","title":"Interfaces","text":""},{"location":"api/ir/#provider","title":"Provider","text":"<p>Base interface for path-based I/O.</p> <pre><code>type Provider interface {\n    NewWriter(ctx context.Context, path string) (IRWriter, error)\n    NewReader(ctx context.Context, path string) (IRReader, error)\n}\n</code></pre>"},{"location":"api/ir/#streamprovider","title":"StreamProvider","text":"<p>Extended interface for stream-based I/O.</p> <pre><code>type StreamProvider interface {\n    NewStreamWriter(w io.Writer) IRWriter\n    NewStreamReader(r io.Reader) (IRReader, error)\n}\n</code></pre>"},{"location":"api/ir/#irwriter","title":"IRWriter","text":"<p>Writer interface for IR records.</p> <pre><code>type IRWriter interface {\n    Write(record *IRRecord) error\n    Flush() error\n    Close() error\n}\n</code></pre>"},{"location":"api/ir/#irreader","title":"IRReader","text":"<p>Reader interface for IR records.</p> <pre><code>type IRReader interface {\n    Read() (*IRRecord, error)\n    Close() error\n}\n</code></pre>"},{"location":"api/ir/#functions","title":"Functions","text":""},{"location":"api/ir/#newrecord","title":"NewRecord","text":"<p>Create a new IR record with builder methods.</p> <pre><code>func NewRecord(method RequestMethod, path string, status int) *IRRecord\n</code></pre> <p>Example:</p> <pre><code>record := ir.NewRecord(ir.RequestMethodGET, \"/users\", 200).\n    SetID(\"req-001\").\n    SetHost(\"api.example.com\").\n    SetRequestBody(requestBody).\n    SetResponseBody(responseBody).\n    SetDuration(45.2)\n</code></pre>"},{"location":"api/ir/#ndjson","title":"NDJSON","text":"<p>Create an NDJSON provider.</p> <pre><code>func NDJSON(opts ...ProviderOption) *NDJSONProvider\n</code></pre>"},{"location":"api/ir/#gzipndjson","title":"GzipNDJSON","text":"<p>Create a gzip-compressed NDJSON provider.</p> <pre><code>func GzipNDJSON(opts ...GzipNDJSONOption) *GzipNDJSONProvider\n\nfunc WithGzipCompressionLevel(level int) GzipNDJSONOption\n</code></pre>"},{"location":"api/ir/#storage","title":"Storage","text":"<p>Create a storage provider using an omnistorage backend.</p> <pre><code>func Storage(backend omnistorage.Backend, opts ...StorageProviderOption) *StorageProvider\n</code></pre>"},{"location":"api/ir/#channel","title":"Channel","text":"<p>Create a channel provider for in-memory I/O.</p> <pre><code>func Channel(opts ...ChannelProviderOption) *ChannelProvider\n\nfunc WithChannelProviderBufferSize(size int) ChannelProviderOption\nfunc WithExistingChannel(ch chan *IRRecord) ChannelProviderOption\n</code></pre>"},{"location":"api/ir/#newloggingtransport","title":"NewLoggingTransport","text":"<p>Create an http.RoundTripper that logs traffic.</p> <pre><code>func NewLoggingTransport(rt http.RoundTripper, writer IRWriter, opts ...LoggingOption) *LoggingTransport\n\nfunc WithFilterHeaders(headers ...string) LoggingOption\nfunc WithSkipPaths(paths ...string) LoggingOption\nfunc WithAllowMethods(methods ...string) LoggingOption\nfunc WithSkipStatusCodes(codes ...int) LoggingOption\nfunc WithRequestIDHeaders(headers ...string) LoggingOption\nfunc WithErrorHandler(handler func(error)) LoggingOption\n</code></pre>"},{"location":"api/ir/#readfile","title":"ReadFile","text":"<p>Read IR records from a file.</p> <pre><code>func ReadFile(path string) ([]*IRRecord, error)\n</code></pre>"},{"location":"api/ir/#writefile","title":"WriteFile","text":"<p>Write IR records to a file.</p> <pre><code>func WriteFile(path string, records []*IRRecord) error\n</code></pre>"},{"location":"api/ir/#readdir","title":"ReadDir","text":"<p>Read IR records from a directory.</p> <pre><code>func ReadDir(path string) ([]*IRRecord, error)\n</code></pre>"},{"location":"api/ir/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n\n    \"github.com/grokify/traffic2openapi/pkg/ir\"\n)\n\nfunc main() {\n    ctx := context.Background()\n\n    // Create provider\n    provider := ir.GzipNDJSON()\n\n    // Write records\n    writer, _ := provider.NewWriter(ctx, \"traffic.ndjson.gz\")\n\n    record := ir.NewRecord(ir.RequestMethodGET, \"/users\", 200).\n        SetID(\"req-001\").\n        SetHost(\"api.example.com\")\n\n    writer.Write(record)\n    writer.Close()\n\n    // Read records\n    reader, _ := provider.NewReader(ctx, \"traffic.ndjson.gz\")\n    for {\n        record, err := reader.Read()\n        if err == io.EOF {\n            break\n        }\n        fmt.Printf(\"Request: %s %s\\n\", record.Request.Method, record.Request.Path)\n    }\n    reader.Close()\n\n    // Use LoggingTransport\n    writer2, _ := provider.NewWriter(ctx, \"live-traffic.ndjson.gz\")\n    transport := ir.NewLoggingTransport(http.DefaultTransport, writer2,\n        ir.WithFilterHeaders(\"Authorization\"),\n    )\n    client := &amp;http.Client{Transport: transport}\n\n    resp, _ := client.Get(\"https://api.example.com/users\")\n    resp.Body.Close()\n    writer2.Close()\n}\n</code></pre>"},{"location":"cli/commands/","title":"CLI Commands","text":"<p>The <code>traffic2openapi</code> CLI provides commands for converting traffic and generating OpenAPI specs.</p>"},{"location":"cli/commands/#installation","title":"Installation","text":"<pre><code>go install github.com/grokify/traffic2openapi/cmd/traffic2openapi@latest\n</code></pre>"},{"location":"cli/commands/#commands-overview","title":"Commands Overview","text":"Command Description <code>generate</code> Generate OpenAPI spec from IR files <code>convert har</code> Convert HAR files to IR format <code>validate</code> Validate IR files <code>site</code> Generate static HTML documentation site"},{"location":"cli/commands/#generate","title":"generate","text":"<p>Generate OpenAPI specification from IR files.</p>"},{"location":"cli/commands/#usage","title":"Usage","text":"<pre><code>traffic2openapi generate -i &lt;input&gt; -o &lt;output&gt; [flags]\n</code></pre>"},{"location":"cli/commands/#flags","title":"Flags","text":"Flag Short Default Description <code>--input</code> <code>-i</code> (required) Input file or directory <code>--output</code> <code>-o</code> stdout Output file path <code>--version</code> <code>-v</code> <code>3.1</code> OpenAPI version: 3.0, 3.1, or 3.2 <code>--format</code> <code>-f</code> auto Output format: json or yaml <code>--title</code> <code>Generated API</code> API title <code>--description</code> API description <code>--api-version</code> <code>1.0.0</code> API version <code>--server</code> Server URL (repeatable) <code>--include-errors</code> <code>true</code> Include 4xx/5xx responses"},{"location":"cli/commands/#examples","title":"Examples","text":"<pre><code># Basic generation\ntraffic2openapi generate -i traffic.ndjson -o openapi.yaml\n\n# OpenAPI 3.0 in JSON\ntraffic2openapi generate -i traffic.ndjson -o api.json --version 3.0 --format json\n\n# With metadata\ntraffic2openapi generate -i traffic.ndjson -o openapi.yaml \\\n    --title \"User Service API\" \\\n    --description \"API for managing users\" \\\n    --api-version \"2.0.0\" \\\n    --server https://api.example.com \\\n    --server https://staging.example.com\n\n# From directory\ntraffic2openapi generate -i ./traffic-logs/ -o openapi.yaml\n</code></pre>"},{"location":"cli/commands/#convert-har","title":"convert har","text":"<p>Convert HAR (HTTP Archive) files to IR format.</p>"},{"location":"cli/commands/#usage_1","title":"Usage","text":"<pre><code>traffic2openapi convert har -i &lt;input&gt; -o &lt;output&gt; [flags]\n</code></pre>"},{"location":"cli/commands/#flags_1","title":"Flags","text":"Flag Short Default Description <code>--input</code> <code>-i</code> (required) HAR file or directory <code>--output</code> <code>-o</code> (required) Output IR file <code>--host</code> Filter by host <code>--method</code> Filter by HTTP method <code>--headers</code> <code>true</code> Include headers"},{"location":"cli/commands/#examples_1","title":"Examples","text":"<pre><code># Single file\ntraffic2openapi convert har -i recording.har -o traffic.ndjson\n\n# Directory of HAR files\ntraffic2openapi convert har -i ./har-files/ -o traffic.ndjson\n\n# Filter by host\ntraffic2openapi convert har -i recording.har -o traffic.ndjson --host api.example.com\n\n# Filter by method\ntraffic2openapi convert har -i recording.har -o traffic.ndjson --method POST\n\n# Without headers\ntraffic2openapi convert har -i recording.har -o traffic.ndjson --headers=false\n</code></pre>"},{"location":"cli/commands/#validate","title":"validate","text":"<p>Validate IR files against the schema.</p>"},{"location":"cli/commands/#usage_2","title":"Usage","text":"<pre><code>traffic2openapi validate &lt;path&gt; [flags]\n</code></pre>"},{"location":"cli/commands/#flags_2","title":"Flags","text":"Flag Default Description <code>--verbose</code> <code>false</code> Show detailed validation output"},{"location":"cli/commands/#examples_2","title":"Examples","text":"<pre><code># Validate file\ntraffic2openapi validate traffic.ndjson\n\n# Validate directory\ntraffic2openapi validate ./logs/\n\n# Verbose output\ntraffic2openapi validate traffic.ndjson --verbose\n</code></pre>"},{"location":"cli/commands/#common-workflows","title":"Common Workflows","text":""},{"location":"cli/commands/#har-to-openapi","title":"HAR to OpenAPI","text":"<pre><code># 1. Convert HAR\ntraffic2openapi convert har -i browser.har -o traffic.ndjson\n\n# 2. Generate spec\ntraffic2openapi generate -i traffic.ndjson -o openapi.yaml\n</code></pre>"},{"location":"cli/commands/#combining-multiple-sources","title":"Combining Multiple Sources","text":"<pre><code># Combine multiple HAR files\ntraffic2openapi convert har -i ./har-files/ -o combined.ndjson\n\n# Generate from combined\ntraffic2openapi generate -i combined.ndjson -o openapi.yaml \\\n    --title \"My API\" \\\n    --server https://api.example.com\n</code></pre>"},{"location":"cli/commands/#pipeline","title":"Pipeline","text":"<pre><code># Convert and generate in one pipeline\ntraffic2openapi convert har -i recording.har -o - | \\\n    traffic2openapi generate -i - -o openapi.yaml\n</code></pre>"},{"location":"cli/commands/#site","title":"site","text":"<p>Generate a static HTML documentation site from IR traffic logs.</p>"},{"location":"cli/commands/#usage_3","title":"Usage","text":"<pre><code>traffic2openapi site -i &lt;input_file_or_dir&gt; -o &lt;output_dir&gt; [flags]\n</code></pre>"},{"location":"cli/commands/#flags_3","title":"Flags","text":"Flag Short Default Description <code>--input</code> <code>-i</code> (required) Input IR file (<code>.ndjson</code>, <code>.json</code>) or directory <code>--output</code> <code>-o</code> <code>./site/</code> Output directory for generated HTML files <code>--title</code> <code>API Traffic Documentation</code> Site title <code>--base-url</code> Base URL for links (e.g., <code>/docs/api/</code>)"},{"location":"cli/commands/#examples_3","title":"Examples","text":"<pre><code># Basic site generation\ntraffic2openapi site -i traffic.ndjson -o ./site/\n\n# With custom title\ntraffic2openapi site -i traffic.ndjson -o ./docs/ --title \"My API Documentation\"\n\n# From directory of IR files\ntraffic2openapi site -i ./logs/ -o ./site/\n\n# With base URL for hosting under a subdirectory\ntraffic2openapi site -i traffic.ndjson -o ./site/ --base-url /api-docs/\n</code></pre>"},{"location":"cli/commands/#features","title":"Features","text":"<p>The generated site includes:</p> <ul> <li>Index page: Lists all endpoints with method badges, request counts, and status codes</li> <li>Endpoint pages: Detailed view of each endpoint grouped by HTTP status code</li> <li>Two views per status code:<ul> <li>Deduped view: Collapsed view showing all seen parameter values (e.g., <code>userId: 123, 456</code>)</li> <li>Distinct view: Individual requests with full request/response details</li> </ul> </li> <li>Path template detection: Automatically detects path parameters like <code>/users/{userId}</code></li> <li>Light/dark mode: Theme toggle with localStorage persistence</li> <li>Copy buttons: One-click copying of JSON bodies</li> <li>Syntax highlighting: Color-coded JSON for better readability</li> <li>Responsive design: Works on desktop and mobile</li> </ul>"},{"location":"cli/commands/#output-structure","title":"Output Structure","text":"<pre><code>./site/\n\u251c\u2500\u2500 index.html              # Endpoint listing\n\u251c\u2500\u2500 get-users.html          # GET /users endpoint page\n\u251c\u2500\u2500 get-users-userid.html   # GET /users/{userId} endpoint page\n\u251c\u2500\u2500 post-users.html         # POST /users endpoint page\n\u2514\u2500\u2500 assets/\n    \u251c\u2500\u2500 style.css           # Light/dark theme styles\n    \u2514\u2500\u2500 script.js           # Theme toggle, copy buttons, highlighting\n</code></pre>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>Traffic2OpenAPI uses a layered architecture to convert HTTP traffic from various sources into OpenAPI specifications.</p>"},{"location":"concepts/architecture/#overview","title":"Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                    TRAFFIC SOURCES                                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Browser          \u2502 Test Automation  \u2502 Go Applications  \u2502 Proxy Captures   \u2502 Manual       \u2502\n\u2502 HAR Files        \u2502 Playwright, etc  \u2502 LoggingTransport \u2502 mitmproxy, etc   \u2502 Capture      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                  \u2502                  \u2502                  \u2502                 \u2502\n         \u25bc                  \u25bc                  \u25bc                  \u25bc                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                           ADAPTER LAYER (source-specific)                                \u2502\n\u2502                    HAR Adapter | Playwright Adapter | LoggingTransport                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                              \u2502\n                                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        IR (Intermediate Representation)                                  \u2502\n\u2502                           JSON Schema v1 contract                                        \u2502\n\u2502                                                                                          \u2502\n\u2502         Providers: NDJSON | GzipNDJSON | Storage | Channel                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                              \u2502\n                                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                               GO CORE ENGINE                                             \u2502\n\u2502        IR Reader \u2192 Endpoint Clustering \u2192 Schema Inference \u2192 OpenAPI Generator            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                              \u2502\n                                              \u25bc\n                                   OpenAPI 3.0/3.1/3.2 Spec\n</code></pre>"},{"location":"concepts/architecture/#components","title":"Components","text":""},{"location":"concepts/architecture/#traffic-sources","title":"Traffic Sources","text":"<p>HTTP traffic can be captured from various sources:</p> Source Method Full Bodies Setup Complexity Browser DevTools HAR export Yes Low Playwright/Cypress HAR or events Yes Low LoggingTransport Go http.Client Yes Low Proxy captures mitmproxy, Charles Yes Low-Medium"},{"location":"concepts/architecture/#adapter-layer","title":"Adapter Layer","text":"<p>Adapters convert source-specific formats to the common IR format:</p> <ul> <li>HAR Adapter: Parses HTTP Archive files from browsers and proxies</li> <li>Playwright Adapter: Captures traffic during test automation</li> <li>LoggingTransport: Captures traffic from Go http.Client in real-time</li> </ul>"},{"location":"concepts/architecture/#ir-intermediate-representation","title":"IR (Intermediate Representation)","text":"<p>The IR is the universal format that all adapters output and the inference engine consumes:</p> <ul> <li>NDJSON format: One JSON record per line, ideal for streaming</li> <li>Batch JSON format: Array of records for file-based processing</li> <li>Provider pattern: Symmetric read/write access via Providers</li> </ul> <p>See IR Format for the complete schema.</p>"},{"location":"concepts/architecture/#providers","title":"Providers","text":"<p>Providers offer symmetric read/write access to IR records:</p> Provider Use Case Streaming <code>NDJSONProvider</code> Plain NDJSON files Yes <code>GzipNDJSONProvider</code> Compressed NDJSON Yes <code>StorageProvider</code> Cloud storage via omnistorage Yes <code>ChannelProvider</code> In-memory Go channels Yes <p>See Provider Pattern for usage details.</p>"},{"location":"concepts/architecture/#inference-engine","title":"Inference Engine","text":"<p>The inference engine analyzes IR records to discover API structure:</p> <ol> <li>Endpoint Clustering: Groups requests by HTTP method + path pattern</li> <li>Path Parameter Detection: Identifies dynamic segments (UUIDs, IDs, etc.)</li> <li>Schema Inference: Builds JSON Schema from request/response bodies</li> <li>Format Detection: Recognizes email, date-time, URI, IP addresses</li> </ol>"},{"location":"concepts/architecture/#openapi-generator","title":"OpenAPI Generator","text":"<p>Converts inference results to OpenAPI 3.0/3.1/3.2 specifications:</p> <ul> <li>Generates paths with parameters</li> <li>Creates component schemas</li> <li>Adds request/response examples</li> <li>Supports YAML and JSON output</li> </ul>"},{"location":"concepts/architecture/#data-flow","title":"Data Flow","text":"<pre><code>1. Capture    \u2192 Traffic captured at source (browser, proxy, code)\n2. Convert    \u2192 Adapter converts to IR format\n3. Store      \u2192 Provider writes IR records (file, cloud, memory)\n4. Read       \u2192 Provider reads IR records\n5. Analyze    \u2192 Inference engine processes records\n6. Generate   \u2192 OpenAPI spec created from inference results\n</code></pre>"},{"location":"concepts/architecture/#integration-points","title":"Integration Points","text":""},{"location":"concepts/architecture/#with-omnistorage","title":"With omnistorage","text":"<p>The StorageProvider integrates with omnistorage for cloud storage:</p> <pre><code>import (\n    \"github.com/grokify/omnistorage/backend/s3\"\n    \"github.com/grokify/traffic2openapi/pkg/ir\"\n)\n\nbackend, _ := s3.New(ctx, s3.Config{...})\nprovider := ir.Storage(backend)\nwriter, _ := provider.NewWriter(ctx, \"records.ndjson.gz\")\n</code></pre>"},{"location":"concepts/architecture/#with-httpclient","title":"With http.Client","text":"<p>The LoggingTransport wraps <code>http.RoundTripper</code> to capture traffic:</p> <pre><code>transport := ir.NewLoggingTransport(http.DefaultTransport, writer)\nclient := &amp;http.Client{Transport: transport}\n// All requests through this client are logged to the writer\n</code></pre>"},{"location":"concepts/ir-format/","title":"Intermediate Representation (IR)","text":"<p>The IR is the shared contract between all traffic sources and the Go processing engine.</p>"},{"location":"concepts/ir-format/#formats","title":"Formats","text":"<p>IR supports two serialization formats:</p> Format Use Case File Extension NDJSON Streaming, large datasets, cloud storage <code>.ndjson</code>, <code>.ndjson.gz</code> Batch JSON File-based processing, small datasets <code>.json</code>"},{"location":"concepts/ir-format/#schema","title":"Schema","text":"<p>The JSON Schema is available at: <code>schemas/ir.v1.schema.json</code></p>"},{"location":"concepts/ir-format/#ndjson-format-recommended","title":"NDJSON Format (Recommended)","text":"<p>Each line is a complete JSON record:</p> <pre><code>{\"id\":\"req-001\",\"request\":{\"method\":\"GET\",\"host\":\"api.example.com\",\"path\":\"/users\"},\"response\":{\"status\":200,\"body\":{\"users\":[]}}}\n{\"id\":\"req-002\",\"request\":{\"method\":\"POST\",\"host\":\"api.example.com\",\"path\":\"/users\",\"body\":{\"name\":\"Bob\"}},\"response\":{\"status\":201,\"body\":{\"id\":\"456\"}}}\n</code></pre> <p>Benefits:</p> <ul> <li>Streaming-friendly: process line by line</li> <li>Append-only: easy to add records</li> <li>Compression: gzip works well with NDJSON</li> </ul>"},{"location":"concepts/ir-format/#batch-json-format","title":"Batch JSON Format","text":"<p>Array of records with metadata wrapper:</p> <pre><code>{\n  \"version\": \"ir.v1\",\n  \"metadata\": {\n    \"generatedAt\": \"2024-12-30T10:00:00Z\",\n    \"source\": \"manual\",\n    \"recordCount\": 2\n  },\n  \"records\": [\n    {\n      \"id\": \"req-001\",\n      \"timestamp\": \"2024-12-30T09:00:00Z\",\n      \"request\": {\n        \"method\": \"GET\",\n        \"host\": \"api.example.com\",\n        \"path\": \"/users\",\n        \"query\": { \"limit\": \"10\" }\n      },\n      \"response\": {\n        \"status\": 200,\n        \"contentType\": \"application/json\",\n        \"body\": { \"users\": [], \"total\": 0 }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"concepts/ir-format/#ir-record-fields","title":"IR Record Fields","text":""},{"location":"concepts/ir-format/#required-fields","title":"Required Fields","text":"Field Type Description <code>request.method</code> string HTTP method (GET, POST, PUT, PATCH, DELETE, etc.) <code>request.path</code> string Raw request path without query string <code>response.status</code> integer HTTP status code (100-599)"},{"location":"concepts/ir-format/#optional-fields","title":"Optional Fields","text":"Field Type Description <code>id</code> string Unique record identifier <code>timestamp</code> string ISO 8601 timestamp <code>source</code> string Adapter type: <code>har</code>, <code>playwright</code>, <code>logging-transport</code>, <code>proxy</code>, <code>manual</code> <code>request.scheme</code> string <code>http</code> or <code>https</code> <code>request.host</code> string Request host header <code>request.pathTemplate</code> string Normalized path with parameters (e.g., <code>/users/{id}</code>) <code>request.pathParams</code> object Extracted path parameter values <code>request.query</code> object Query parameters <code>request.headers</code> object Request headers (lowercase keys) <code>request.contentType</code> string Content-Type header <code>request.body</code> any Parsed request body (object, array, string, or null) <code>response.headers</code> object Response headers <code>response.contentType</code> string Response Content-Type <code>response.body</code> any Parsed response body <code>durationMs</code> number Round-trip time in milliseconds"},{"location":"concepts/ir-format/#go-types","title":"Go Types","text":"<p>The <code>pkg/ir</code> package provides Go types for working with IR data:</p> <pre><code>// IRRecord represents a single HTTP request/response capture\ntype IRRecord struct {\n    ID         *string   `json:\"id,omitempty\"`\n    Timestamp  *string   `json:\"timestamp,omitempty\"`\n    Source     *string   `json:\"source,omitempty\"`\n    Request    Request   `json:\"request\"`\n    Response   Response  `json:\"response\"`\n    DurationMs *float64  `json:\"durationMs,omitempty\"`\n}\n\n// Request contains HTTP request details\ntype Request struct {\n    Method       RequestMethod          `json:\"method\"`\n    Scheme       *string                `json:\"scheme,omitempty\"`\n    Host         *string                `json:\"host,omitempty\"`\n    Path         string                 `json:\"path\"`\n    PathTemplate *string                `json:\"pathTemplate,omitempty\"`\n    PathParams   map[string]string      `json:\"pathParams,omitempty\"`\n    Query        map[string]string      `json:\"query,omitempty\"`\n    Headers      map[string]string      `json:\"headers,omitempty\"`\n    ContentType  *string                `json:\"contentType,omitempty\"`\n    Body         interface{}            `json:\"body,omitempty\"`\n}\n\n// Response contains HTTP response details\ntype Response struct {\n    Status      int                    `json:\"status\"`\n    Headers     map[string]string      `json:\"headers,omitempty\"`\n    ContentType *string                `json:\"contentType,omitempty\"`\n    Body        interface{}            `json:\"body,omitempty\"`\n}\n</code></pre>"},{"location":"concepts/ir-format/#creating-records","title":"Creating Records","text":"<p>Use the builder pattern for creating records:</p> <pre><code>record := ir.NewRecord(ir.RequestMethodPOST, \"/api/users\", 201).\n    SetID(\"req-001\").\n    SetHost(\"api.example.com\").\n    SetRequestBody(map[string]string{\"name\": \"Alice\"}).\n    SetResponseBody(map[string]interface{}{\"id\": \"123\", \"name\": \"Alice\"}).\n    SetDuration(45.2)\n</code></pre>"},{"location":"concepts/ir-format/#reading-and-writing","title":"Reading and Writing","text":"<p>See Provider Pattern for the recommended way to read and write IR records.</p> <p>Quick example:</p> <pre><code>// Read from file\nrecords, err := ir.ReadFile(\"traffic.ndjson\")\n\n// Write to file\nerr := ir.WriteFile(\"output.ndjson\", records)\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#cli-tool","title":"CLI Tool","text":"<p>Install the CLI tool using Go:</p> <pre><code>go install github.com/grokify/traffic2openapi/cmd/traffic2openapi@latest\n</code></pre> <p>Verify the installation:</p> <pre><code>traffic2openapi --help\n</code></pre>"},{"location":"getting-started/installation/#go-package","title":"Go Package","text":"<p>Add the package to your Go project:</p> <pre><code>go get github.com/grokify/traffic2openapi\n</code></pre> <p>Import the packages you need:</p> <pre><code>import (\n    \"github.com/grokify/traffic2openapi/pkg/ir\"\n    \"github.com/grokify/traffic2openapi/pkg/inference\"\n    \"github.com/grokify/traffic2openapi/pkg/openapi\"\n)\n</code></pre>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Go 1.21 or later</li> <li>For CLI: no additional dependencies</li> <li>For Go package: dependencies are managed via go.mod</li> </ul>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For cloud storage integration:</p> <pre><code>go get github.com/grokify/omnistorage\n</code></pre> <p>This enables storing and reading IR records from various cloud storage backends (S3, GCS, Azure Blob, etc.).</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide walks you through generating an OpenAPI spec from HTTP traffic.</p>"},{"location":"getting-started/quickstart/#step-1-capture-traffic","title":"Step 1: Capture Traffic","text":"<p>The easiest way to capture HTTP traffic is using a HAR file from your browser's DevTools:</p> <ol> <li>Open Chrome/Firefox DevTools (F12)</li> <li>Go to the Network tab</li> <li>Perform your API operations</li> <li>Right-click \u2192 Save all as HAR</li> </ol> <p>Alternatively, use the LoggingTransport in your Go code to capture traffic programmatically.</p>"},{"location":"getting-started/quickstart/#step-2-convert-to-ir-format","title":"Step 2: Convert to IR Format","text":"<p>Convert the HAR file to the Intermediate Representation (IR) format:</p> <pre><code>traffic2openapi convert har -i recording.har -o traffic.ndjson\n</code></pre>"},{"location":"getting-started/quickstart/#step-3-generate-openapi-spec","title":"Step 3: Generate OpenAPI Spec","text":"<p>Generate an OpenAPI specification from the IR file:</p> <pre><code>traffic2openapi generate -i traffic.ndjson -o openapi.yaml\n</code></pre>"},{"location":"getting-started/quickstart/#step-4-review-and-customize","title":"Step 4: Review and Customize","text":"<p>The generated spec will have:</p> <ul> <li>Endpoints discovered from traffic patterns</li> <li>Path parameters inferred from URL patterns</li> <li>Request/response schemas inferred from bodies</li> <li>Query parameters extracted from URLs</li> </ul> <p>You can customize the output:</p> <pre><code>traffic2openapi generate -i traffic.ndjson -o openapi.yaml \\\n  --title \"My API\" \\\n  --api-version \"2.0.0\" \\\n  --server https://api.example.com\n</code></pre>"},{"location":"getting-started/quickstart/#go-package-quick-start","title":"Go Package Quick Start","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n\n    \"github.com/grokify/traffic2openapi/pkg/ir\"\n    \"github.com/grokify/traffic2openapi/pkg/inference\"\n    \"github.com/grokify/traffic2openapi/pkg/openapi\"\n)\n\nfunc main() {\n    ctx := context.Background()\n\n    // Option 1: Read from file\n    records, err := ir.ReadFile(\"traffic.ndjson\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Option 2: Create records programmatically\n    record := ir.NewRecord(ir.RequestMethodGET, \"/users\", 200).\n        SetID(\"req-001\").\n        SetHost(\"api.example.com\").\n        SetResponseBody(map[string]interface{}{\n            \"users\": []interface{}{},\n            \"total\": 0,\n        })\n\n    // Process records through inference engine\n    engine := inference.NewEngine(inference.DefaultEngineOptions())\n    engine.ProcessRecords(records)\n    result := engine.Finalize()\n\n    // Generate OpenAPI spec\n    options := openapi.DefaultGeneratorOptions()\n    options.Title = \"My API\"\n    options.Version = openapi.Version31\n\n    spec := openapi.GenerateFromInference(result, options)\n\n    // Write to file\n    if err := openapi.WriteFile(\"openapi.yaml\", spec); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about the Provider Pattern for symmetric IR read/write</li> <li>Explore LoggingTransport for capturing live HTTP traffic</li> <li>See Adapters for different traffic sources</li> </ul>"},{"location":"go-packages/inference/","title":"Inference Engine","text":"<p>The inference engine analyzes IR records to discover API structure, path parameters, and schemas.</p>"},{"location":"go-packages/inference/#overview","title":"Overview","text":"<p>The inference engine processes IR records and produces:</p> <ul> <li>Endpoint patterns: Discovered API endpoints with path templates</li> <li>Path parameters: Dynamic URL segments (UUIDs, IDs, slugs)</li> <li>Request schemas: JSON Schema for request bodies</li> <li>Response schemas: JSON Schema for response bodies by status code</li> <li>Query parameters: Discovered query string parameters</li> </ul>"},{"location":"go-packages/inference/#basic-usage","title":"Basic Usage","text":"<pre><code>import \"github.com/grokify/traffic2openapi/pkg/inference\"\n\n// Create engine with default options\nengine := inference.NewEngine(inference.DefaultEngineOptions())\n\n// Process records\nengine.ProcessRecords(records)\n\n// Get results\nresult := engine.Finalize()\n\n// Result contains discovered endpoints and schemas\nfor path, endpoint := range result.Endpoints {\n    fmt.Printf(\"Endpoint: %s\\n\", path)\n    for method, operation := range endpoint.Operations {\n        fmt.Printf(\"  %s: %d requests\\n\", method, operation.RequestCount)\n    }\n}\n</code></pre>"},{"location":"go-packages/inference/#engine-options","title":"Engine Options","text":"<pre><code>options := inference.EngineOptions{\n    // Path parameter detection\n    DetectPathParams: true,\n\n    // Minimum occurrences to consider a pattern\n    MinOccurrences: 2,\n\n    // Include 4xx/5xx responses in schema inference\n    IncludeErrorResponses: true,\n\n    // Maximum depth for schema inference\n    MaxSchemaDepth: 10,\n\n    // Merge similar schemas\n    MergeSchemas: true,\n}\n\nengine := inference.NewEngine(options)\n</code></pre>"},{"location":"go-packages/inference/#path-parameter-detection","title":"Path Parameter Detection","text":"<p>The engine automatically detects dynamic path segments:</p> Pattern Detected As Example UUID <code>{id}</code> <code>/users/550e8400-e29b-41d4-a716-446655440000</code> Numeric ID <code>{id}</code> <code>/users/12345</code> Short hash <code>{hash}</code> <code>/commits/a1b2c3d</code> Date <code>{date}</code> <code>/reports/2024-01-15</code> Slug <code>{slug}</code> <code>/posts/hello-world</code> <p>Context-aware naming:</p> <pre><code>/users/123        \u2192 /users/{userId}\n/posts/456        \u2192 /posts/{postId}\n/orders/789/items \u2192 /orders/{orderId}/items\n</code></pre>"},{"location":"go-packages/inference/#schema-inference","title":"Schema Inference","text":""},{"location":"go-packages/inference/#type-detection","title":"Type Detection","text":"JSON Type Inferred Type <code>\"hello\"</code> <code>string</code> <code>123</code> <code>integer</code> <code>12.5</code> <code>number</code> <code>true</code> <code>boolean</code> <code>[]</code> <code>array</code> <code>{}</code> <code>object</code> <code>null</code> nullable"},{"location":"go-packages/inference/#format-detection","title":"Format Detection","text":"Pattern Format <code>user@example.com</code> <code>email</code> <code>550e8400-e29b-...</code> <code>uuid</code> <code>2024-01-15T10:30:00Z</code> <code>date-time</code> <code>2024-01-15</code> <code>date</code> <code>https://example.com</code> <code>uri</code> <code>192.168.1.1</code> <code>ipv4</code> <code>::1</code> <code>ipv6</code>"},{"location":"go-packages/inference/#required-vs-optional","title":"Required vs Optional","text":"<p>Fields are tracked across multiple requests:</p> <pre><code>// Request 1: {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n// Request 2: {\"name\": \"Bob\"}\n// Request 3: {\"name\": \"Charlie\", \"email\": \"charlie@example.com\"}\n\n// Result:\n// - \"name\" is required (present in all requests)\n// - \"email\" is optional (present in 2/3 requests)\n</code></pre>"},{"location":"go-packages/inference/#result-structure","title":"Result Structure","text":"<pre><code>type InferenceResult struct {\n    // Discovered endpoints keyed by path template\n    Endpoints map[string]*Endpoint\n\n    // Global schemas that can be reused\n    Schemas map[string]*Schema\n}\n\ntype Endpoint struct {\n    // Path template (e.g., \"/users/{userId}\")\n    PathTemplate string\n\n    // Path parameters\n    PathParams []PathParam\n\n    // Operations keyed by HTTP method\n    Operations map[string]*Operation\n}\n\ntype Operation struct {\n    // HTTP method\n    Method string\n\n    // Number of requests observed\n    RequestCount int\n\n    // Query parameters\n    QueryParams []QueryParam\n\n    // Request body schema\n    RequestSchema *Schema\n\n    // Response schemas keyed by status code\n    ResponseSchemas map[int]*Schema\n}\n</code></pre>"},{"location":"go-packages/inference/#processing-modes","title":"Processing Modes","text":""},{"location":"go-packages/inference/#batch-processing","title":"Batch Processing","text":"<pre><code>// Process all records at once\nengine := inference.NewEngine(options)\nengine.ProcessRecords(records)\nresult := engine.Finalize()\n</code></pre>"},{"location":"go-packages/inference/#streaming-processing","title":"Streaming Processing","text":"<pre><code>// Process records one at a time\nengine := inference.NewEngine(options)\n\nreader, _ := provider.NewReader(ctx, \"traffic.ndjson\")\nfor {\n    record, err := reader.Read()\n    if err == io.EOF {\n        break\n    }\n    engine.ProcessRecord(record)\n}\n\nresult := engine.Finalize()\n</code></pre>"},{"location":"go-packages/inference/#incremental-processing","title":"Incremental Processing","text":"<pre><code>// Add more records to existing engine\nengine.ProcessRecords(batch1)\n// ... later ...\nengine.ProcessRecords(batch2)\n// Only finalize when done\nresult := engine.Finalize()\n</code></pre>"},{"location":"go-packages/inference/#convenience-functions","title":"Convenience Functions","text":"<pre><code>// Infer from directory of IR files\nresult, err := inference.InferFromDir(\"./traffic/\")\n\n// Infer from single file\nresult, err := inference.InferFromFile(\"traffic.ndjson\")\n</code></pre>"},{"location":"go-packages/inference/#integration-with-openapi-generator","title":"Integration with OpenAPI Generator","text":"<pre><code>import (\n    \"github.com/grokify/traffic2openapi/pkg/inference\"\n    \"github.com/grokify/traffic2openapi/pkg/openapi\"\n)\n\n// Infer API structure\nengine := inference.NewEngine(inference.DefaultEngineOptions())\nengine.ProcessRecords(records)\nresult := engine.Finalize()\n\n// Generate OpenAPI spec\noptions := openapi.DefaultGeneratorOptions()\noptions.Title = \"My API\"\noptions.Version = openapi.Version31\n\nspec := openapi.GenerateFromInference(result, options)\nopenapi.WriteFile(\"openapi.yaml\", spec)\n</code></pre>"},{"location":"go-packages/inference/#best-practices","title":"Best Practices","text":""},{"location":"go-packages/inference/#sufficient-sample-size","title":"Sufficient Sample Size","text":"<p>More requests lead to better inference:</p> <ul> <li>Path parameters: Need multiple values to detect patterns</li> <li>Required fields: Need multiple requests to distinguish required/optional</li> <li>Response schemas: Need examples of each status code</li> </ul>"},{"location":"go-packages/inference/#representative-traffic","title":"Representative Traffic","text":"<p>Capture diverse traffic for best results:</p> <ul> <li>All API endpoints</li> <li>Various query parameter combinations</li> <li>Different request body shapes</li> <li>Success and error responses</li> </ul>"},{"location":"go-packages/inference/#pre-filtering","title":"Pre-filtering","text":"<p>Filter traffic before inference:</p> <pre><code>// Only process successful responses\nvar filtered []*ir.IRRecord\nfor _, record := range records {\n    if record.Response.Status &gt;= 200 &amp;&amp; record.Response.Status &lt; 300 {\n        filtered = append(filtered, record)\n    }\n}\nengine.ProcessRecords(filtered)\n</code></pre>"},{"location":"go-packages/logging-transport/","title":"LoggingTransport","text":"<p>LoggingTransport is an <code>http.RoundTripper</code> that captures HTTP traffic from Go's <code>http.Client</code>.</p>"},{"location":"go-packages/logging-transport/#overview","title":"Overview","text":"<p>LoggingTransport wraps any <code>http.RoundTripper</code> (typically <code>http.DefaultTransport</code>) and records all HTTP request/response pairs to an <code>IRWriter</code>.</p> <pre><code>transport := ir.NewLoggingTransport(http.DefaultTransport, writer)\nclient := &amp;http.Client{Transport: transport}\n\n// All requests through this client are automatically logged\nresp, err := client.Get(\"https://api.example.com/users\")\n</code></pre>"},{"location":"go-packages/logging-transport/#basic-usage","title":"Basic Usage","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"net/http\"\n\n    \"github.com/grokify/traffic2openapi/pkg/ir\"\n)\n\nfunc main() {\n    ctx := context.Background()\n\n    // Create a provider and writer\n    provider := ir.GzipNDJSON()\n    writer, _ := provider.NewWriter(ctx, \"traffic.ndjson.gz\")\n    defer writer.Close()\n\n    // Wrap the default transport\n    transport := ir.NewLoggingTransport(http.DefaultTransport, writer)\n\n    // Create client with logging transport\n    client := &amp;http.Client{Transport: transport}\n\n    // Make requests - they're automatically captured\n    resp, _ := client.Get(\"https://api.example.com/users\")\n    defer resp.Body.Close()\n\n    // POST with body\n    client.Post(\"https://api.example.com/users\",\n        \"application/json\",\n        strings.NewReader(`{\"name\": \"Alice\"}`))\n}\n</code></pre>"},{"location":"go-packages/logging-transport/#configuration-options","title":"Configuration Options","text":""},{"location":"go-packages/logging-transport/#header-filtering","title":"Header Filtering","text":"<p>Exclude sensitive headers from captured records:</p> <pre><code>transport := ir.NewLoggingTransport(http.DefaultTransport, writer,\n    ir.WithFilterHeaders(\"Authorization\", \"Cookie\", \"X-API-Key\"),\n)\n</code></pre> <p>Default filtered headers:</p> <ul> <li><code>Authorization</code></li> <li><code>Cookie</code></li> <li><code>Set-Cookie</code></li> <li><code>X-API-Key</code></li> <li><code>X-Auth-Token</code></li> </ul>"},{"location":"go-packages/logging-transport/#path-filtering","title":"Path Filtering","text":"<p>Skip logging for specific paths:</p> <pre><code>transport := ir.NewLoggingTransport(http.DefaultTransport, writer,\n    ir.WithSkipPaths(\"/health\", \"/metrics\", \"/ping\"),\n)\n</code></pre>"},{"location":"go-packages/logging-transport/#method-filtering","title":"Method Filtering","text":"<p>Only log specific HTTP methods:</p> <pre><code>transport := ir.NewLoggingTransport(http.DefaultTransport, writer,\n    ir.WithAllowMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\"),\n)\n</code></pre>"},{"location":"go-packages/logging-transport/#status-code-filtering","title":"Status Code Filtering","text":"<p>Skip logging for specific status codes:</p> <pre><code>transport := ir.NewLoggingTransport(http.DefaultTransport, writer,\n    ir.WithSkipStatusCodes(404, 500, 502, 503),\n)\n</code></pre>"},{"location":"go-packages/logging-transport/#request-id-headers","title":"Request ID Headers","text":"<p>Extract request IDs from headers:</p> <pre><code>transport := ir.NewLoggingTransport(http.DefaultTransport, writer,\n    ir.WithRequestIDHeaders(\"X-Request-ID\", \"X-Correlation-ID\"),\n)\n</code></pre> <p>If no header is found, a UUID is generated.</p>"},{"location":"go-packages/logging-transport/#error-handler","title":"Error Handler","text":"<p>Custom error handling:</p> <pre><code>transport := ir.NewLoggingTransport(http.DefaultTransport, writer,\n    ir.WithErrorHandler(func(err error) {\n        log.Printf(\"logging error: %v\", err)\n    }),\n)\n</code></pre>"},{"location":"go-packages/logging-transport/#full-example-with-options","title":"Full Example with Options","text":"<pre><code>transport := ir.NewLoggingTransport(http.DefaultTransport, writer,\n    // Security\n    ir.WithFilterHeaders(\"Authorization\", \"Cookie\", \"X-API-Key\"),\n\n    // Skip non-API paths\n    ir.WithSkipPaths(\"/health\", \"/metrics\", \"/_next\"),\n\n    // Only log mutations\n    ir.WithAllowMethods(\"POST\", \"PUT\", \"PATCH\", \"DELETE\"),\n\n    // Skip error responses\n    ir.WithSkipStatusCodes(500, 502, 503),\n\n    // Correlation\n    ir.WithRequestIDHeaders(\"X-Request-ID\", \"X-Trace-ID\"),\n\n    // Error handling\n    ir.WithErrorHandler(func(err error) {\n        slog.Error(\"traffic logging failed\", \"error\", err)\n    }),\n)\n\nclient := &amp;http.Client{Transport: transport}\n</code></pre>"},{"location":"go-packages/logging-transport/#captured-data","title":"Captured Data","text":"<p>Each request/response pair is captured as an <code>IRRecord</code>:</p> Field Captured Request method Yes Request path Yes Request query params Yes Request headers Yes (filtered) Request body Yes (JSON parsed) Response status Yes Response headers Yes Response body Yes (JSON parsed) Duration Yes Timestamp Yes Request ID Yes (from header or generated)"},{"location":"go-packages/logging-transport/#integration-patterns","title":"Integration Patterns","text":""},{"location":"go-packages/logging-transport/#with-channel-provider-for-real-time-processing","title":"With Channel Provider for Real-time Processing","text":"<pre><code>provider := ir.Channel(ir.WithChannelProviderBufferSize(1000))\n\n// Writer for transport\nwriter, _ := provider.NewWriter(ctx, \"\")\n\n// Reader for processing\nreader, _ := provider.NewReader(ctx, \"\")\n\n// Process records in background\ngo func() {\n    for {\n        record, err := reader.Read()\n        if err == io.EOF {\n            break\n        }\n        // Real-time processing: metrics, alerts, etc.\n        processRecord(record)\n    }\n}()\n\n// HTTP client with logging\ntransport := ir.NewLoggingTransport(http.DefaultTransport, writer)\nclient := &amp;http.Client{Transport: transport}\n</code></pre>"},{"location":"go-packages/logging-transport/#with-multiwriter-for-multiple-destinations","title":"With MultiWriter for Multiple Destinations","text":"<pre><code>// Write to file and channel simultaneously\nfileWriter, _ := fileProvider.NewWriter(ctx, \"traffic.ndjson.gz\")\nchannelWriter, _ := channelProvider.NewWriter(ctx, \"\")\n\nmultiWriter := ir.NewMultiWriter(fileWriter, channelWriter)\n\ntransport := ir.NewLoggingTransport(http.DefaultTransport, multiWriter)\nclient := &amp;http.Client{Transport: transport}\n</code></pre>"},{"location":"go-packages/logging-transport/#with-async-writer-for-non-blocking-logging","title":"With Async Writer for Non-blocking Logging","text":"<pre><code>// Async writer doesn't block HTTP requests\nasyncWriter := ir.NewAsyncNDJSONWriter(baseWriter, 1000)\ndefer asyncWriter.Close()\n\ntransport := ir.NewLoggingTransport(http.DefaultTransport, asyncWriter)\nclient := &amp;http.Client{Transport: transport}\n</code></pre>"},{"location":"go-packages/logging-transport/#testing","title":"Testing","text":"<p>LoggingTransport works well with <code>httptest</code>:</p> <pre><code>func TestAPI(t *testing.T) {\n    // Setup test server\n    server := httptest.NewServer(http.HandlerFunc(handler))\n    defer server.Close()\n\n    // Capture traffic\n    var records []*ir.IRRecord\n    sliceWriter := ir.NewSliceWriter(&amp;records)\n\n    transport := ir.NewLoggingTransport(http.DefaultTransport, sliceWriter)\n    client := &amp;http.Client{Transport: transport}\n\n    // Make requests\n    client.Get(server.URL + \"/users\")\n\n    // Verify captured traffic\n    if len(records) != 1 {\n        t.Errorf(\"expected 1 record, got %d\", len(records))\n    }\n}\n</code></pre>"},{"location":"go-packages/logging-transport/#thread-safety","title":"Thread Safety","text":"<p>LoggingTransport is safe for concurrent use. Multiple goroutines can share the same client:</p> <pre><code>client := &amp;http.Client{Transport: transport}\n\nvar wg sync.WaitGroup\nfor i := 0; i &lt; 100; i++ {\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        client.Get(\"https://api.example.com/users\")\n    }()\n}\nwg.Wait()\n</code></pre> <p>The underlying <code>IRWriter</code> must also be thread-safe. All built-in writers (NDJSONWriter, GzipNDJSONWriter, ChannelWriter) are thread-safe.</p>"},{"location":"go-packages/openapi/","title":"OpenAPI Generator","text":"<p>The OpenAPI generator creates OpenAPI 3.0/3.1/3.2 specifications from inference results.</p>"},{"location":"go-packages/openapi/#overview","title":"Overview","text":"<pre><code>import \"github.com/grokify/traffic2openapi/pkg/openapi\"\n\n// Generate from inference results\nspec := openapi.GenerateFromInference(result, openapi.DefaultGeneratorOptions())\n\n// Write to file\nopenapi.WriteFile(\"openapi.yaml\", spec)\n</code></pre>"},{"location":"go-packages/openapi/#supported-versions","title":"Supported Versions","text":"Version Constant Description 3.0.3 <code>openapi.Version30</code> Wide compatibility 3.1.0 <code>openapi.Version31</code> JSON Schema 2020-12 (default) 3.2.0 <code>openapi.Version32</code> Latest features"},{"location":"go-packages/openapi/#generator-options","title":"Generator Options","text":"<pre><code>options := openapi.GeneratorOptions{\n    // OpenAPI version\n    Version: openapi.Version31,\n\n    // API metadata\n    Title:       \"My API\",\n    Description: \"API generated from traffic\",\n    APIVersion:  \"1.0.0\",\n\n    // Server URLs\n    Servers: []string{\n        \"https://api.example.com\",\n        \"https://staging.example.com\",\n    },\n\n    // Include 4xx/5xx responses\n    IncludeErrors: true,\n\n    // Contact information\n    ContactName:  \"API Support\",\n    ContactEmail: \"support@example.com\",\n    ContactURL:   \"https://example.com/support\",\n\n    // License\n    LicenseName: \"MIT\",\n    LicenseURL:  \"https://opensource.org/licenses/MIT\",\n}\n\nspec := openapi.GenerateFromInference(result, options)\n</code></pre>"},{"location":"go-packages/openapi/#output-formats","title":"Output Formats","text":""},{"location":"go-packages/openapi/#yaml-recommended","title":"YAML (recommended)","text":"<pre><code>// Write to YAML file\nopenapi.WriteFile(\"openapi.yaml\", spec)\n\n// Convert to YAML string\nyaml, err := openapi.ToString(spec, openapi.FormatYAML)\n</code></pre>"},{"location":"go-packages/openapi/#json","title":"JSON","text":"<pre><code>// Write to JSON file\nopenapi.WriteFile(\"openapi.json\", spec)\n\n// Convert to JSON string\njson, err := openapi.ToString(spec, openapi.FormatJSON)\n</code></pre>"},{"location":"go-packages/openapi/#generated-structure","title":"Generated Structure","text":"<p>The generator produces a complete OpenAPI specification:</p> <pre><code>openapi: 3.1.0\ninfo:\n  title: My API\n  version: 1.0.0\nservers:\n  - url: https://api.example.com\npaths:\n  /users:\n    get:\n      summary: Get users\n      parameters:\n        - name: limit\n          in: query\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/GetUsersResponse'\n  /users/{userId}:\n    get:\n      parameters:\n        - name: userId\n          in: path\n          required: true\n          schema:\n            type: string\ncomponents:\n  schemas:\n    GetUsersResponse:\n      type: object\n      properties:\n        users:\n          type: array\n          items:\n            $ref: '#/components/schemas/User'\n</code></pre>"},{"location":"go-packages/openapi/#schema-references","title":"Schema References","text":"<p>The generator automatically creates reusable schemas in <code>components/schemas</code>:</p> <ul> <li>Request body schemas: <code>{OperationId}Request</code></li> <li>Response schemas: <code>{OperationId}Response</code></li> <li>Nested objects: Extracted and referenced</li> </ul>"},{"location":"go-packages/openapi/#customization","title":"Customization","text":""},{"location":"go-packages/openapi/#post-processing","title":"Post-processing","text":"<p>Modify the spec after generation:</p> <pre><code>spec := openapi.GenerateFromInference(result, options)\n\n// Add security schemes\nspec.Components.SecuritySchemes = map[string]interface{}{\n    \"bearerAuth\": map[string]string{\n        \"type\":   \"http\",\n        \"scheme\": \"bearer\",\n    },\n}\n\n// Add tags\nspec.Tags = []map[string]string{\n    {\"name\": \"users\", \"description\": \"User operations\"},\n    {\"name\": \"orders\", \"description\": \"Order operations\"},\n}\n\nopenapi.WriteFile(\"openapi.yaml\", spec)\n</code></pre>"},{"location":"go-packages/openapi/#multiple-servers","title":"Multiple Servers","text":"<pre><code>options.Servers = []string{\n    \"https://api.example.com\",\n    \"https://staging.example.com\",\n    \"http://localhost:8080\",\n}\n</code></pre>"},{"location":"go-packages/openapi/#full-example","title":"Full Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n\n    \"github.com/grokify/traffic2openapi/pkg/inference\"\n    \"github.com/grokify/traffic2openapi/pkg/ir\"\n    \"github.com/grokify/traffic2openapi/pkg/openapi\"\n)\n\nfunc main() {\n    ctx := context.Background()\n\n    // Read traffic\n    provider := ir.NDJSON()\n    reader, err := provider.NewReader(ctx, \"traffic.ndjson\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    var records []*ir.IRRecord\n    for {\n        record, err := reader.Read()\n        if err != nil {\n            break\n        }\n        records = append(records, record)\n    }\n    reader.Close()\n\n    // Infer API structure\n    engine := inference.NewEngine(inference.DefaultEngineOptions())\n    engine.ProcessRecords(records)\n    result := engine.Finalize()\n\n    // Generate OpenAPI spec\n    options := openapi.GeneratorOptions{\n        Version:     openapi.Version31,\n        Title:       \"User Service API\",\n        Description: \"API for managing users\",\n        APIVersion:  \"2.0.0\",\n        Servers:     []string{\"https://api.example.com/v2\"},\n    }\n\n    spec := openapi.GenerateFromInference(result, options)\n\n    // Write YAML\n    if err := openapi.WriteFile(\"openapi.yaml\", spec); err != nil {\n        log.Fatal(err)\n    }\n\n    // Also write JSON\n    if err := openapi.WriteFile(\"openapi.json\", spec); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"go-packages/openapi/#cli-usage","title":"CLI Usage","text":"<p>The CLI provides the same functionality:</p> <pre><code># Basic generation\ntraffic2openapi generate -i traffic.ndjson -o openapi.yaml\n\n# With options\ntraffic2openapi generate -i traffic.ndjson -o openapi.yaml \\\n    --title \"My API\" \\\n    --api-version \"2.0.0\" \\\n    --version 3.1 \\\n    --server https://api.example.com \\\n    --server https://staging.example.com\n</code></pre>"},{"location":"go-packages/overview/","title":"Go Packages Overview","text":"<p>The <code>traffic2openapi</code> module provides several packages for working with HTTP traffic and generating OpenAPI specifications.</p>"},{"location":"go-packages/overview/#package-structure","title":"Package Structure","text":"<pre><code>pkg/\n\u251c\u2500\u2500 ir/                  # IR types, providers, readers, writers\n\u251c\u2500\u2500 inference/           # Traffic analysis and schema inference\n\u2514\u2500\u2500 openapi/             # OpenAPI spec generation\n</code></pre>"},{"location":"go-packages/overview/#pkgir","title":"pkg/ir","text":"<p>The <code>ir</code> package provides types and utilities for working with Intermediate Representation data.</p>"},{"location":"go-packages/overview/#key-features","title":"Key Features","text":"<ul> <li>IR Types: <code>IRRecord</code>, <code>Request</code>, <code>Response</code>, <code>Batch</code></li> <li>Provider Pattern: Symmetric read/write via <code>Provider</code> interface</li> <li>Built-in Providers: NDJSON, GzipNDJSON, Storage, Channel</li> <li>LoggingTransport: Capture traffic from <code>http.Client</code></li> <li>File I/O: Read/write NDJSON and batch JSON files</li> </ul> <pre><code>import \"github.com/grokify/traffic2openapi/pkg/ir\"\n\n// Create a record\nrecord := ir.NewRecord(ir.RequestMethodGET, \"/users\", 200)\n\n// Use a provider for I/O\nprovider := ir.NDJSON()\nwriter, _ := provider.NewWriter(ctx, \"output.ndjson\")\nwriter.Write(record)\nwriter.Close()\n</code></pre> <p>See:</p> <ul> <li>Provider Pattern - Detailed provider documentation</li> <li>LoggingTransport - HTTP client traffic capture</li> </ul>"},{"location":"go-packages/overview/#pkginference","title":"pkg/inference","text":"<p>The <code>inference</code> package analyzes IR records to discover API structure.</p>"},{"location":"go-packages/overview/#key-features_1","title":"Key Features","text":"<ul> <li>Path Template Inference: <code>/users/123</code> \u2192 <code>/users/{userId}</code></li> <li>Schema Inference: JSON Schema from request/response bodies</li> <li>Format Detection: email, uuid, date-time, uri, ipv4, ipv6</li> <li>Endpoint Clustering: Groups requests by method + path</li> </ul> <pre><code>import \"github.com/grokify/traffic2openapi/pkg/inference\"\n\nengine := inference.NewEngine(inference.DefaultEngineOptions())\nengine.ProcessRecords(records)\nresult := engine.Finalize()\n</code></pre> <p>See Inference Engine for details.</p>"},{"location":"go-packages/overview/#pkgopenapi","title":"pkg/openapi","text":"<p>The <code>openapi</code> package generates OpenAPI 3.0/3.1/3.2 specifications.</p>"},{"location":"go-packages/overview/#key-features_2","title":"Key Features","text":"<ul> <li>Version Support: OpenAPI 3.0.3, 3.1.0, 3.2.0</li> <li>Output Formats: YAML and JSON</li> <li>Customization: Title, description, servers, version</li> </ul> <pre><code>import \"github.com/grokify/traffic2openapi/pkg/openapi\"\n\noptions := openapi.DefaultGeneratorOptions()\noptions.Title = \"My API\"\noptions.Version = openapi.Version31\n\nspec := openapi.GenerateFromInference(result, options)\nopenapi.WriteFile(\"openapi.yaml\", spec)\n</code></pre> <p>See OpenAPI Generator for details.</p>"},{"location":"go-packages/overview/#common-patterns","title":"Common Patterns","text":""},{"location":"go-packages/overview/#end-to-end-pipeline","title":"End-to-End Pipeline","text":"<pre><code>// 1. Capture traffic\nprovider := ir.NDJSON()\nwriter, _ := provider.NewWriter(ctx, \"traffic.ndjson\")\ntransport := ir.NewLoggingTransport(http.DefaultTransport, writer)\nclient := &amp;http.Client{Transport: transport}\n\n// ... make HTTP requests with client ...\n\nwriter.Close()\n\n// 2. Read and analyze\nreader, _ := provider.NewReader(ctx, \"traffic.ndjson\")\nvar records []*ir.IRRecord\nfor {\n    record, err := reader.Read()\n    if err == io.EOF {\n        break\n    }\n    records = append(records, record)\n}\n\n// 3. Infer API structure\nengine := inference.NewEngine(inference.DefaultEngineOptions())\nengine.ProcessRecords(records)\nresult := engine.Finalize()\n\n// 4. Generate OpenAPI\nspec := openapi.GenerateFromInference(result, openapi.DefaultGeneratorOptions())\nopenapi.WriteFile(\"openapi.yaml\", spec)\n</code></pre>"},{"location":"go-packages/overview/#with-cloud-storage","title":"With Cloud Storage","text":"<pre><code>import (\n    \"github.com/grokify/omnistorage/backend/s3\"\n    \"github.com/grokify/traffic2openapi/pkg/ir\"\n)\n\n// Setup S3 backend\nbackend, _ := s3.New(ctx, s3.Config{\n    Bucket: \"my-bucket\",\n    Region: \"us-east-1\",\n})\ndefer backend.Close()\n\n// Use storage provider\nprovider := ir.Storage(backend)\n\n// Write compressed NDJSON to S3\nwriter, _ := provider.NewWriter(ctx, \"traffic/2024/01/records.ndjson.gz\")\n</code></pre>"},{"location":"go-packages/providers/","title":"Provider Pattern","text":"<p>Providers offer symmetric read/write access to IR records through a unified interface.</p>"},{"location":"go-packages/providers/#overview","title":"Overview","text":"<p>The Provider pattern decouples IR record I/O from the underlying storage mechanism. All providers implement the same interface, making it easy to switch between file storage, cloud storage, or in-memory channels.</p>"},{"location":"go-packages/providers/#interfaces","title":"Interfaces","text":""},{"location":"go-packages/providers/#provider","title":"Provider","text":"<p>The base interface for path-based I/O:</p> <pre><code>type Provider interface {\n    // NewWriter creates a writer for the given path.\n    NewWriter(ctx context.Context, path string) (IRWriter, error)\n\n    // NewReader creates a reader for the given path.\n    NewReader(ctx context.Context, path string) (IRReader, error)\n}\n</code></pre>"},{"location":"go-packages/providers/#streamprovider","title":"StreamProvider","text":"<p>Extended interface for io.Reader/io.Writer based I/O:</p> <pre><code>type StreamProvider interface {\n    // NewStreamWriter creates a writer that writes to the given io.Writer.\n    NewStreamWriter(w io.Writer) IRWriter\n\n    // NewStreamReader creates a reader that reads from the given io.Reader.\n    NewStreamReader(r io.Reader) (IRReader, error)\n}\n</code></pre>"},{"location":"go-packages/providers/#irwriter-and-irreader","title":"IRWriter and IRReader","text":"<p>Common interfaces for all readers and writers:</p> <pre><code>type IRWriter interface {\n    Write(record *IRRecord) error\n    Flush() error\n    Close() error\n}\n\ntype IRReader interface {\n    Read() (*IRRecord, error)  // Returns io.EOF when done\n    Close() error\n}\n</code></pre>"},{"location":"go-packages/providers/#built-in-providers","title":"Built-in Providers","text":""},{"location":"go-packages/providers/#ndjsonprovider","title":"NDJSONProvider","text":"<p>Plain NDJSON file I/O:</p> <pre><code>provider := ir.NDJSON()\n\n// Write to file\nwriter, err := provider.NewWriter(ctx, \"/path/to/records.ndjson\")\nif err != nil {\n    return err\n}\ndefer writer.Close()\n\nfor _, record := range records {\n    if err := writer.Write(record); err != nil {\n        return err\n    }\n}\n\n// Read from file\nreader, err := provider.NewReader(ctx, \"/path/to/records.ndjson\")\nif err != nil {\n    return err\n}\ndefer reader.Close()\n\nfor {\n    record, err := reader.Read()\n    if err == io.EOF {\n        break\n    }\n    if err != nil {\n        return err\n    }\n    // process record\n}\n</code></pre>"},{"location":"go-packages/providers/#gzipndjsonprovider","title":"GzipNDJSONProvider","text":"<p>Gzip-compressed NDJSON:</p> <pre><code>// Default compression\nprovider := ir.GzipNDJSON()\n\n// Custom compression level (1-9, or gzip constants)\nprovider := ir.GzipNDJSON(ir.WithGzipCompressionLevel(gzip.BestCompression))\n\n// Write compressed file\nwriter, _ := provider.NewWriter(ctx, \"/path/to/records.ndjson.gz\")\n\n// Read compressed file\nreader, _ := provider.NewReader(ctx, \"/path/to/records.ndjson.gz\")\n</code></pre>"},{"location":"go-packages/providers/#storageprovider","title":"StorageProvider","text":"<p>Cloud storage via omnistorage:</p> <pre><code>import (\n    \"github.com/grokify/omnistorage/backend/file\"\n    \"github.com/grokify/omnistorage/backend/s3\"\n    \"github.com/grokify/traffic2openapi/pkg/ir\"\n)\n\n// Local file backend\nbackend := file.New(file.Config{Root: \"/data\"})\ndefer backend.Close()\n\n// Or S3 backend\nbackend, _ := s3.New(ctx, s3.Config{\n    Bucket: \"my-bucket\",\n    Region: \"us-east-1\",\n})\ndefer backend.Close()\n\n// Create provider\nprovider := ir.Storage(backend)\n\n// Auto-detects format from extension:\n// - .ndjson \u2192 plain NDJSON\n// - .ndjson.gz \u2192 gzip-compressed NDJSON\nwriter, _ := provider.NewWriter(ctx, \"traffic/records.ndjson.gz\")\nreader, _ := provider.NewReader(ctx, \"traffic/records.ndjson.gz\")\n</code></pre>"},{"location":"go-packages/providers/#channelprovider","title":"ChannelProvider","text":"<p>In-memory Go channels for pipelines:</p> <pre><code>// Create provider with buffered channel\nprovider := ir.Channel(ir.WithChannelProviderBufferSize(100))\n\n// Or use existing channel\nch := make(chan *ir.IRRecord, 100)\nprovider := ir.Channel(ir.WithExistingChannel(ch))\n\n// Writer sends to channel\nwriter, _ := provider.NewWriter(ctx, \"\")  // path ignored\n\n// Reader receives from channel\nreader, _ := provider.NewReader(ctx, \"\")  // path ignored\n\n// Concurrent pipeline example\ngo func() {\n    writer, _ := provider.NewWriter(ctx, \"\")\n    for _, record := range records {\n        writer.Write(record)\n    }\n    writer.Close()  // Closes channel, signals EOF to reader\n}()\n\nreader, _ := provider.NewReader(ctx, \"\")\nfor {\n    record, err := reader.Read()\n    if err == io.EOF {\n        break\n    }\n    // process record\n}\n</code></pre>"},{"location":"go-packages/providers/#stream-based-io","title":"Stream-based I/O","text":"<p>Providers that implement <code>StreamProvider</code> support io.Reader/io.Writer directly:</p> <pre><code>provider := ir.NDJSON()\n\n// Write to any io.Writer\nvar buf bytes.Buffer\nwriter := provider.NewStreamWriter(&amp;buf)\nwriter.Write(record)\nwriter.Close()\n\n// Read from any io.Reader\nreader, _ := provider.NewStreamReader(&amp;buf)\n</code></pre> <p>This is useful for:</p> <ul> <li>HTTP request/response bodies</li> <li>Network connections</li> <li>Pipes</li> <li>Testing</li> </ul>"},{"location":"go-packages/providers/#common-patterns","title":"Common Patterns","text":""},{"location":"go-packages/providers/#processing-pipeline","title":"Processing Pipeline","text":"<pre><code>// Source provider (e.g., S3)\nsrcBackend, _ := s3.New(ctx, srcConfig)\nsrcProvider := ir.Storage(srcBackend)\n\n// Destination provider (e.g., local file)\ndstProvider := ir.GzipNDJSON()\n\n// Copy records\nreader, _ := srcProvider.NewReader(ctx, \"input.ndjson\")\nwriter, _ := dstProvider.NewWriter(ctx, \"/local/output.ndjson.gz\")\n\nfor {\n    record, err := reader.Read()\n    if err == io.EOF {\n        break\n    }\n    if err != nil {\n        return err\n    }\n    if err := writer.Write(record); err != nil {\n        return err\n    }\n}\n\nreader.Close()\nwriter.Close()\n</code></pre>"},{"location":"go-packages/providers/#multi-writer-tee","title":"Multi-writer (Tee)","text":"<p>Write to multiple destinations:</p> <pre><code>// Create writers\nfileWriter, _ := fileProvider.NewWriter(ctx, \"records.ndjson\")\nchannelWriter, _ := channelProvider.NewWriter(ctx, \"\")\n\n// Use MultiWriter\nmultiWriter := ir.NewMultiWriter(fileWriter, channelWriter)\ndefer multiWriter.Close()\n\nfor _, record := range records {\n    multiWriter.Write(record)  // Writes to both\n}\n</code></pre>"},{"location":"go-packages/providers/#with-loggingtransport","title":"With LoggingTransport","text":"<p>Capture HTTP traffic directly to a provider:</p> <pre><code>provider := ir.GzipNDJSON()\nwriter, _ := provider.NewWriter(ctx, \"traffic.ndjson.gz\")\ndefer writer.Close()\n\ntransport := ir.NewLoggingTransport(http.DefaultTransport, writer)\nclient := &amp;http.Client{Transport: transport}\n\n// All requests through this client are captured\nresp, _ := client.Get(\"https://api.example.com/users\")\n</code></pre>"},{"location":"go-packages/providers/#error-handling","title":"Error Handling","text":"<p>All providers follow Go error handling conventions:</p> <pre><code>writer, err := provider.NewWriter(ctx, path)\nif err != nil {\n    return fmt.Errorf(\"creating writer: %w\", err)\n}\ndefer writer.Close()\n\nfor _, record := range records {\n    if err := writer.Write(record); err != nil {\n        return fmt.Errorf(\"writing record: %w\", err)\n    }\n}\n\nif err := writer.Close(); err != nil {\n    return fmt.Errorf(\"closing writer: %w\", err)\n}\n</code></pre> <p>Context cancellation is supported:</p> <pre><code>ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\nwriter, err := provider.NewWriter(ctx, path)\n// Returns error if context is cancelled\n</code></pre>"}]}